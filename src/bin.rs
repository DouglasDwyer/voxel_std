use std::env::*;
use std::fs::*;
use std::path::*;
use std::process::*;

/// Recursively invokes `cargo` to build the given mod.
fn build_mod(name: &str, out_path: &Path, binary_output: &mut String, list_output: &mut String) {
    let result = Command::new("cargo")
        .arg("build")
        .arg("-p")
        .arg(name)
        .arg("--release")
        .arg("--target")
        .arg("wasm32-wasip1")
        .spawn()
        .expect("Failed to start mod build.")
        .wait()
        .expect("Failed to build mod.");

    if result.success() {
        let mut path_buf = PathBuf::from(out_path);
        path_buf.push("target");
        path_buf.push("wasm32-wasip1");
        path_buf.push("release");
        path_buf.push(format!("{name}.wasm"));
        assert!(path_buf.exists(), "Mod not found at path: {path_buf:?}");

        let literal_name = name.to_uppercase();
        let wasm = read(&path_buf).expect("Could not read WASM output.");
        let _ = std::fmt::Write::write_fmt(binary_output, format_args!(
            "/// The WASM binary for the `{name}` mod.\n\
            pub const {literal_name}: &[u8] = b\"{}\";",
            to_byte_string_literal(&wasm)
        ));
        
        let _ = std::fmt::Write::write_fmt(list_output, format_args!(
            "StandardMod {{ name: \"{name}\", module: {literal_name} }},"
        ));
    }
    else {
        panic!("Failed to generate {name} mod");
    }
}

/// Converts a sequence of bytes to a string literal.
fn to_byte_string_literal(bytes: &[u8]) -> String {
    let mut lit = String::new();
    for &byte in bytes {
        if 40 <= byte && byte <= 126 && ![39, 92, 10, 13].contains(&byte) {
            lit.push(std::char::from_u32(byte as u32).unwrap());
        } else {
            let _ = std::fmt::Write::write_fmt(&mut lit, format_args!("\\x{byte:02X}"));
        }
    }
    lit
}

/// Builds all WASM plugins and embeds them for consumption as byte arrays.
fn main() {
    let mut binary_output = String::default();
    let mut list_output = String::default();
    
    let out_dir = current_dir().expect("Failed to get current directory.");
    let out_path = Path::new(&out_dir);

    for mod_name in ["player_controller"] {
        build_mod(mod_name, out_path, &mut binary_output, &mut list_output);
    }

    write(
        out_path.join("src/autogenerated.rs"),
        format!("{binary_output}\
        /// Holds a list containing all standard mods.\n\
        pub const STANDARD_MODS: &[StandardMod] = &[{list_output}];")
    )
    .expect("Could not write WASM mod Rust file.");
}